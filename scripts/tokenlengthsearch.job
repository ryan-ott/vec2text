#!/bin/bash

#SBATCH --partition=gpu
#SBATCH --gpus=1
#SBATCH --job-name=Reproducetokenlengthspace
#SBATCH --ntasks=1
#SBATCH --cpus-per-task=18
#SBATCH --time=20:00:00
#SBATCH --output=/home/scur0989/vec2text/scripts/outputs/slurms/token_length_search_%j.out

module purge
module load 2022
module load Anaconda3/2022.05

source /home/scur0989/v2t-env/bin/activate
cd /home/scur0989/vec2text/

# --- Configuration ---
dataset="fiqa"  # CHANGE HERE: Dataset to use
start_len=32
step_size=4
error_threshold=5.0  # Threshold for stopping the search
beam_width=4
steps=50
max_samples=500

# Dataset-specific maximum lengths
declare -A max_lengths=(
    ["quora"]=15
    ["signal1m"]=23
    ["msmarco"]=72
    ["climate-fever"]=73
    ["fever"]=73
    ["dbpedia-entity"]=91
    ["nq"]=94
    ["hotpotqa"]=94
    ["fiqa"]=103
    ["webis-touche2020"]=105
    ["cqadupstack"]=106
    ["arguana"]=113
    ["scidocs"]=125
    ["trec-covid"]=125
    ["robust04"]=127
    ["bioasq"]=127
    ["scifact"]=127
    ["nfcorpus"]=127
    ["trec-news"]=128
)

# Define output directories
slurm_output_dir="/home/scur0989/vec2text/scripts/outputs/slurms"
log_output_dir="/home/scur0989/vec2text/scripts/outputs/logs"

# Create output directories if they don't exist
mkdir -p "$slurm_output_dir"
mkdir -p "$log_output_dir"

# --- Helper Functions ---
# Function to extract BLEU score from log file (updated for new log location)
get_bleu_score() {
    local log_file=$1
    # Wait for the log file to be created and populated
    while [ ! -f "$log_file" ] || [ ! -s "$log_file" ]; do
        sleep 10
    done
    # Extract BLEU score using grep and awk
    bleu_score=$(grep "eval_bleu_score:" "$log_file" | tail -n 1 | awk '{print $2}')

    # Check if BLEU score was successfully extracted
    if [[ -z "$bleu_score" ]]; then
        echo "INVALID"
        return
    fi

    echo "$bleu_score"
}

# Function to run the experiment for a given max_length (updated for new log location)
run_experiment() {
    local max_len=$1

    # Check if length is within valid range
    if [ $max_len -lt 0 ] || [ $max_len -gt $max_allowed_len ]; then
        echo "INVALID"
        return
    fi
    
    local log_file="$log_output_dir/repro_T2_gtr-${steps}steps-${beam_width}beam_${dataset}_${max_samples}samples_${max_len}maxtoken.log"

    echo "Running experiment with max_length=$max_len..."
    echo "SLURM output: ${slurm_output_dir}/token_length_search_%j.out"
    echo "Log file: ${log_file}"

    # Run the Python script
    python reproduce_T2_fix.py \
        --model jxm/gtr__nq__32__correct \
        --steps $steps \
        --beam-width $beam_width \
        --beir_dataset $dataset \
        --max_samples $max_samples \
        --max_length $max_len > "$log_file" 2>&1

    # Get BLEU score
    local bleu_score=$(get_bleu_score "$log_file")
    echo "$bleu_score"
}

# --- Main Script ---

# Verify dataset is valid and get max length
if [ -z "${max_lengths[$dataset]}" ]; then
    echo "Error: Invalid dataset name. Valid options are: ${!max_lengths[@]}"
    exit 1
fi
max_allowed_len=${max_lengths[$dataset]}

# Create dataset-specific results file in log directory
results_file="$log_output_dir/experiment_results_${dataset}.csv"
echo "max_length,bleu_score,dataset" > "$results_file"

# Run initial experiment at start_len
echo "Starting initial experiment at $start_len tokens..."
initial_bleu=$(run_experiment $start_len)

# If initial bleu is invalid, stop here
if [[ "$initial_bleu" == "INVALID" ]]; then
    echo "Invalid initial BLEU score at $start_len, exiting"
    exit 1
fi
echo "Initial BLEU score at $start_len tokens: $initial_bleu"
echo "$start_len,$initial_bleu,$dataset" >> "$results_file"

# Initialize search direction
direction="down"
current_len=$((start_len - step_size))
search_down=true
search_up=true

# Main loop
while true; do
    if $search_down; then
        # Add minimum token check
        if [ $current_len -le 3 ]; then
            echo "Reached minimum 4 tokens, switching to upward search..."
            search_down=false
            if ! $search_up; then
                break
            fi
            direction="up"
            current_len=$((start_len + step_size))
            continue
        fi

        echo "Testing downward at length $current_len..."
        bleu_score=$(run_experiment $current_len)

        if [[ "$bleu_score" == "INVALID" ]]; then
            echo "Reached minimum length, switching to upward search..."
            search_down=false
            if ! $search_up; then
                break
            fi
            direction="up"
            current_len=$((start_len + step_size))
            continue
        fi

        # Check if BLEU score is approximately 0 or below the error threshold
        if [ $(echo "$bleu_score <= $(echo "0 + $error_threshold" | bc -l)" | bc -l) -eq 1 ] || \
           [ $(echo "$bleu_score >= $(echo "100 - $error_threshold" | bc -l)" | bc -l) -eq 1 ]; then
            echo "Reached threshold at length $current_len"
            search_down=false
            if ! $search_up; then
                break
            fi
            direction="up"
            current_len=$((start_len + step_size))
            continue
        fi
        echo "$current_len,$bleu_score,$dataset" >> "$results_file"
        current_len=$((current_len - step_size))
    elif $search_up; then
        # Add maximum token check
        if [ $((current_len + step_size)) -gt $max_allowed_len ]; then
            echo "Next step would exceed maximum allowed length of $max_allowed_len, ending search..."
            break
        fi

        echo "Testing upward at length $current_len..."
        bleu_score=$(run_experiment $current_len)

        if [[ "$bleu_score" == "INVALID" ]]; then
            echo "Reached maximum length, ending search..."
            break
        fi

        # Check if BLEU score is approximately 100 or above the error threshold
        if [ $(echo "$bleu_score >= $(echo "100 - $error_threshold" | bc -l)" | bc -l) -eq 1 ]; then
            echo "Reached 100% threshold at length $current_len"
            break
        fi
        echo "$current_len,$bleu_score,$dataset" >> "$results_file"
        current_len=$((current_len + step_size))
    else
        break
    fi
done

echo "Experiment complete. Results saved in $results_file"